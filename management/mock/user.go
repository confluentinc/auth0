// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: management/user.go

package mock

import (
	sync "sync"

	github_com_laura_brouckman_auth0_management "github.com/laura-brouckman/auth0/management"
)

// MockUserManagerInterface is a mock of UserManagerInterface interface
type MockUserManagerInterface struct {
	lockCreate sync.Mutex
	CreateFunc func(u *github_com_laura_brouckman_auth0_management.User) error

	lockRead sync.Mutex
	ReadFunc func(id string, opts ...reqOption) (*github_com_laura_brouckman_auth0_management.User, error)

	lockUpdate sync.Mutex
	UpdateFunc func(id string, u *github_com_laura_brouckman_auth0_management.User) error

	lockDelete sync.Mutex
	DeleteFunc func(id string) error

	lockList sync.Mutex
	ListFunc func(opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error)

	lockSearch sync.Mutex
	SearchFunc func(opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error)

	lockListByEmail sync.Mutex
	ListByEmailFunc func(email string, opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error)

	lockGetRoles sync.Mutex
	GetRolesFunc func(id string, opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.Role, error)

	lockAssignRoles sync.Mutex
	AssignRolesFunc func(id string, roles ...*github_com_laura_brouckman_auth0_management.Role) error

	lockUnassignRoles sync.Mutex
	UnassignRolesFunc func(id string, roles ...*github_com_laura_brouckman_auth0_management.Role) error

	calls struct {
		Create []struct {
			U *github_com_laura_brouckman_auth0_management.User
		}
		Read []struct {
			Id   string
			Opts []reqOption
		}
		Update []struct {
			Id string
			U  *github_com_laura_brouckman_auth0_management.User
		}
		Delete []struct {
			Id string
		}
		List []struct {
			Opts []reqOption
		}
		Search []struct {
			Opts []reqOption
		}
		ListByEmail []struct {
			Email string
			Opts  []reqOption
		}
		GetRoles []struct {
			Id   string
			Opts []reqOption
		}
		AssignRoles []struct {
			Id    string
			Roles []*github_com_laura_brouckman_auth0_management.Role
		}
		UnassignRoles []struct {
			Id    string
			Roles []*github_com_laura_brouckman_auth0_management.Role
		}
	}
}

// Create mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) Create(u *github_com_laura_brouckman_auth0_management.User) error {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	if m.CreateFunc == nil {
		panic("mocker: MockUserManagerInterface.CreateFunc is nil but MockUserManagerInterface.Create was called.")
	}

	call := struct {
		U *github_com_laura_brouckman_auth0_management.User
	}{
		U: u,
	}

	m.calls.Create = append(m.calls.Create, call)

	return m.CreateFunc(u)
}

// CreateCalled returns true if Create was called at least once.
func (m *MockUserManagerInterface) CreateCalled() bool {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return len(m.calls.Create) > 0
}

// CreateCalls returns the calls made to Create.
func (m *MockUserManagerInterface) CreateCalls() []struct {
	U *github_com_laura_brouckman_auth0_management.User
} {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return m.calls.Create
}

// Read mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) Read(id string, opts ...reqOption) (*github_com_laura_brouckman_auth0_management.User, error) {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	if m.ReadFunc == nil {
		panic("mocker: MockUserManagerInterface.ReadFunc is nil but MockUserManagerInterface.Read was called.")
	}

	call := struct {
		Id   string
		Opts []reqOption
	}{
		Id:   id,
		Opts: opts,
	}

	m.calls.Read = append(m.calls.Read, call)

	return m.ReadFunc(id, opts...)
}

// ReadCalled returns true if Read was called at least once.
func (m *MockUserManagerInterface) ReadCalled() bool {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	return len(m.calls.Read) > 0
}

// ReadCalls returns the calls made to Read.
func (m *MockUserManagerInterface) ReadCalls() []struct {
	Id   string
	Opts []reqOption
} {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	return m.calls.Read
}

// Update mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) Update(id string, u *github_com_laura_brouckman_auth0_management.User) error {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	if m.UpdateFunc == nil {
		panic("mocker: MockUserManagerInterface.UpdateFunc is nil but MockUserManagerInterface.Update was called.")
	}

	call := struct {
		Id string
		U  *github_com_laura_brouckman_auth0_management.User
	}{
		Id: id,
		U:  u,
	}

	m.calls.Update = append(m.calls.Update, call)

	return m.UpdateFunc(id, u)
}

// UpdateCalled returns true if Update was called at least once.
func (m *MockUserManagerInterface) UpdateCalled() bool {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	return len(m.calls.Update) > 0
}

// UpdateCalls returns the calls made to Update.
func (m *MockUserManagerInterface) UpdateCalls() []struct {
	Id string
	U  *github_com_laura_brouckman_auth0_management.User
} {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	return m.calls.Update
}

// Delete mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) Delete(id string) error {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	if m.DeleteFunc == nil {
		panic("mocker: MockUserManagerInterface.DeleteFunc is nil but MockUserManagerInterface.Delete was called.")
	}

	call := struct {
		Id string
	}{
		Id: id,
	}

	m.calls.Delete = append(m.calls.Delete, call)

	return m.DeleteFunc(id)
}

// DeleteCalled returns true if Delete was called at least once.
func (m *MockUserManagerInterface) DeleteCalled() bool {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	return len(m.calls.Delete) > 0
}

// DeleteCalls returns the calls made to Delete.
func (m *MockUserManagerInterface) DeleteCalls() []struct {
	Id string
} {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	return m.calls.Delete
}

// List mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) List(opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error) {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	if m.ListFunc == nil {
		panic("mocker: MockUserManagerInterface.ListFunc is nil but MockUserManagerInterface.List was called.")
	}

	call := struct {
		Opts []reqOption
	}{
		Opts: opts,
	}

	m.calls.List = append(m.calls.List, call)

	return m.ListFunc(opts...)
}

// ListCalled returns true if List was called at least once.
func (m *MockUserManagerInterface) ListCalled() bool {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return len(m.calls.List) > 0
}

// ListCalls returns the calls made to List.
func (m *MockUserManagerInterface) ListCalls() []struct {
	Opts []reqOption
} {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return m.calls.List
}

// Search mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) Search(opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error) {
	m.lockSearch.Lock()
	defer m.lockSearch.Unlock()

	if m.SearchFunc == nil {
		panic("mocker: MockUserManagerInterface.SearchFunc is nil but MockUserManagerInterface.Search was called.")
	}

	call := struct {
		Opts []reqOption
	}{
		Opts: opts,
	}

	m.calls.Search = append(m.calls.Search, call)

	return m.SearchFunc(opts...)
}

// SearchCalled returns true if Search was called at least once.
func (m *MockUserManagerInterface) SearchCalled() bool {
	m.lockSearch.Lock()
	defer m.lockSearch.Unlock()

	return len(m.calls.Search) > 0
}

// SearchCalls returns the calls made to Search.
func (m *MockUserManagerInterface) SearchCalls() []struct {
	Opts []reqOption
} {
	m.lockSearch.Lock()
	defer m.lockSearch.Unlock()

	return m.calls.Search
}

// ListByEmail mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) ListByEmail(email string, opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.User, error) {
	m.lockListByEmail.Lock()
	defer m.lockListByEmail.Unlock()

	if m.ListByEmailFunc == nil {
		panic("mocker: MockUserManagerInterface.ListByEmailFunc is nil but MockUserManagerInterface.ListByEmail was called.")
	}

	call := struct {
		Email string
		Opts  []reqOption
	}{
		Email: email,
		Opts:  opts,
	}

	m.calls.ListByEmail = append(m.calls.ListByEmail, call)

	return m.ListByEmailFunc(email, opts...)
}

// ListByEmailCalled returns true if ListByEmail was called at least once.
func (m *MockUserManagerInterface) ListByEmailCalled() bool {
	m.lockListByEmail.Lock()
	defer m.lockListByEmail.Unlock()

	return len(m.calls.ListByEmail) > 0
}

// ListByEmailCalls returns the calls made to ListByEmail.
func (m *MockUserManagerInterface) ListByEmailCalls() []struct {
	Email string
	Opts  []reqOption
} {
	m.lockListByEmail.Lock()
	defer m.lockListByEmail.Unlock()

	return m.calls.ListByEmail
}

// GetRoles mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) GetRoles(id string, opts ...reqOption) ([]*github_com_laura_brouckman_auth0_management.Role, error) {
	m.lockGetRoles.Lock()
	defer m.lockGetRoles.Unlock()

	if m.GetRolesFunc == nil {
		panic("mocker: MockUserManagerInterface.GetRolesFunc is nil but MockUserManagerInterface.GetRoles was called.")
	}

	call := struct {
		Id   string
		Opts []reqOption
	}{
		Id:   id,
		Opts: opts,
	}

	m.calls.GetRoles = append(m.calls.GetRoles, call)

	return m.GetRolesFunc(id, opts...)
}

// GetRolesCalled returns true if GetRoles was called at least once.
func (m *MockUserManagerInterface) GetRolesCalled() bool {
	m.lockGetRoles.Lock()
	defer m.lockGetRoles.Unlock()

	return len(m.calls.GetRoles) > 0
}

// GetRolesCalls returns the calls made to GetRoles.
func (m *MockUserManagerInterface) GetRolesCalls() []struct {
	Id   string
	Opts []reqOption
} {
	m.lockGetRoles.Lock()
	defer m.lockGetRoles.Unlock()

	return m.calls.GetRoles
}

// AssignRoles mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) AssignRoles(id string, roles ...*github_com_laura_brouckman_auth0_management.Role) error {
	m.lockAssignRoles.Lock()
	defer m.lockAssignRoles.Unlock()

	if m.AssignRolesFunc == nil {
		panic("mocker: MockUserManagerInterface.AssignRolesFunc is nil but MockUserManagerInterface.AssignRoles was called.")
	}

	call := struct {
		Id    string
		Roles []*github_com_laura_brouckman_auth0_management.Role
	}{
		Id:    id,
		Roles: roles,
	}

	m.calls.AssignRoles = append(m.calls.AssignRoles, call)

	return m.AssignRolesFunc(id, roles...)
}

// AssignRolesCalled returns true if AssignRoles was called at least once.
func (m *MockUserManagerInterface) AssignRolesCalled() bool {
	m.lockAssignRoles.Lock()
	defer m.lockAssignRoles.Unlock()

	return len(m.calls.AssignRoles) > 0
}

// AssignRolesCalls returns the calls made to AssignRoles.
func (m *MockUserManagerInterface) AssignRolesCalls() []struct {
	Id    string
	Roles []*github_com_laura_brouckman_auth0_management.Role
} {
	m.lockAssignRoles.Lock()
	defer m.lockAssignRoles.Unlock()

	return m.calls.AssignRoles
}

// UnassignRoles mocks base method by wrapping the associated func.
func (m *MockUserManagerInterface) UnassignRoles(id string, roles ...*github_com_laura_brouckman_auth0_management.Role) error {
	m.lockUnassignRoles.Lock()
	defer m.lockUnassignRoles.Unlock()

	if m.UnassignRolesFunc == nil {
		panic("mocker: MockUserManagerInterface.UnassignRolesFunc is nil but MockUserManagerInterface.UnassignRoles was called.")
	}

	call := struct {
		Id    string
		Roles []*github_com_laura_brouckman_auth0_management.Role
	}{
		Id:    id,
		Roles: roles,
	}

	m.calls.UnassignRoles = append(m.calls.UnassignRoles, call)

	return m.UnassignRolesFunc(id, roles...)
}

// UnassignRolesCalled returns true if UnassignRoles was called at least once.
func (m *MockUserManagerInterface) UnassignRolesCalled() bool {
	m.lockUnassignRoles.Lock()
	defer m.lockUnassignRoles.Unlock()

	return len(m.calls.UnassignRoles) > 0
}

// UnassignRolesCalls returns the calls made to UnassignRoles.
func (m *MockUserManagerInterface) UnassignRolesCalls() []struct {
	Id    string
	Roles []*github_com_laura_brouckman_auth0_management.Role
} {
	m.lockUnassignRoles.Lock()
	defer m.lockUnassignRoles.Unlock()

	return m.calls.UnassignRoles
}

// Reset resets the calls made to the mocked methods.
func (m *MockUserManagerInterface) Reset() {
	m.lockCreate.Lock()
	m.calls.Create = nil
	m.lockCreate.Unlock()
	m.lockRead.Lock()
	m.calls.Read = nil
	m.lockRead.Unlock()
	m.lockUpdate.Lock()
	m.calls.Update = nil
	m.lockUpdate.Unlock()
	m.lockDelete.Lock()
	m.calls.Delete = nil
	m.lockDelete.Unlock()
	m.lockList.Lock()
	m.calls.List = nil
	m.lockList.Unlock()
	m.lockSearch.Lock()
	m.calls.Search = nil
	m.lockSearch.Unlock()
	m.lockListByEmail.Lock()
	m.calls.ListByEmail = nil
	m.lockListByEmail.Unlock()
	m.lockGetRoles.Lock()
	m.calls.GetRoles = nil
	m.lockGetRoles.Unlock()
	m.lockAssignRoles.Lock()
	m.calls.AssignRoles = nil
	m.lockAssignRoles.Unlock()
	m.lockUnassignRoles.Lock()
	m.calls.UnassignRoles = nil
	m.lockUnassignRoles.Unlock()
}
