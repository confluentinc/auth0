// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: management/connection.go

package mock

import (
	sync "sync"

	github_com_confluentinc_auth0_management "github.com/confluentinc/auth0/management"
	github_com_confluentinc_cc_structs_kafka_auth_v1 "github.com/confluentinc/cc-structs/kafka/auth/v1"
)

// MockConnectionManagerInterface is a mock of ConnectionManagerInterface interface
type MockConnectionManagerInterface struct {
	lockCreate sync.Mutex
	CreateFunc func(c *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection) error

	lockRead sync.Mutex
	ReadFunc func(id string, opts ...github_com_confluentinc_auth0_management.ReqOption) (*github_com_confluentinc_cc_structs_kafka_auth_v1.Connection, error)

	lockList sync.Mutex
	ListFunc func(opts ...github_com_confluentinc_auth0_management.ReqOption) ([]*github_com_confluentinc_cc_structs_kafka_auth_v1.Connection, error)

	lockUpdate sync.Mutex
	UpdateFunc func(id string, c *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection) error

	lockDelete sync.Mutex
	DeleteFunc func(id string) error

	lockGetConnectionID sync.Mutex
	GetConnectionIDFunc func(connectionName string) (string, error)

	calls struct {
		Create []struct {
			C *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
		}
		Read []struct {
			Id   string
			Opts []github_com_confluentinc_auth0_management.ReqOption
		}
		List []struct {
			Opts []github_com_confluentinc_auth0_management.ReqOption
		}
		Update []struct {
			Id string
			C  *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
		}
		Delete []struct {
			Id string
		}
		GetConnectionID []struct {
			ConnectionName string
		}
	}
}

// Create mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) Create(c *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection) error {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	if m.CreateFunc == nil {
		panic("mocker: MockConnectionManagerInterface.CreateFunc is nil but MockConnectionManagerInterface.Create was called.")
	}

	call := struct {
		C *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
	}{
		C: c,
	}

	m.calls.Create = append(m.calls.Create, call)

	return m.CreateFunc(c)
}

// CreateCalled returns true if Create was called at least once.
func (m *MockConnectionManagerInterface) CreateCalled() bool {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return len(m.calls.Create) > 0
}

// CreateCalls returns the calls made to Create.
func (m *MockConnectionManagerInterface) CreateCalls() []struct {
	C *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
} {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return m.calls.Create
}

// Read mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) Read(id string, opts ...github_com_confluentinc_auth0_management.ReqOption) (*github_com_confluentinc_cc_structs_kafka_auth_v1.Connection, error) {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	if m.ReadFunc == nil {
		panic("mocker: MockConnectionManagerInterface.ReadFunc is nil but MockConnectionManagerInterface.Read was called.")
	}

	call := struct {
		Id   string
		Opts []github_com_confluentinc_auth0_management.ReqOption
	}{
		Id:   id,
		Opts: opts,
	}

	m.calls.Read = append(m.calls.Read, call)

	return m.ReadFunc(id, opts...)
}

// ReadCalled returns true if Read was called at least once.
func (m *MockConnectionManagerInterface) ReadCalled() bool {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	return len(m.calls.Read) > 0
}

// ReadCalls returns the calls made to Read.
func (m *MockConnectionManagerInterface) ReadCalls() []struct {
	Id   string
	Opts []github_com_confluentinc_auth0_management.ReqOption
} {
	m.lockRead.Lock()
	defer m.lockRead.Unlock()

	return m.calls.Read
}

// List mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) List(opts ...github_com_confluentinc_auth0_management.ReqOption) ([]*github_com_confluentinc_cc_structs_kafka_auth_v1.Connection, error) {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	if m.ListFunc == nil {
		panic("mocker: MockConnectionManagerInterface.ListFunc is nil but MockConnectionManagerInterface.List was called.")
	}

	call := struct {
		Opts []github_com_confluentinc_auth0_management.ReqOption
	}{
		Opts: opts,
	}

	m.calls.List = append(m.calls.List, call)

	return m.ListFunc(opts...)
}

// ListCalled returns true if List was called at least once.
func (m *MockConnectionManagerInterface) ListCalled() bool {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return len(m.calls.List) > 0
}

// ListCalls returns the calls made to List.
func (m *MockConnectionManagerInterface) ListCalls() []struct {
	Opts []github_com_confluentinc_auth0_management.ReqOption
} {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return m.calls.List
}

// Update mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) Update(id string, c *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection) error {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	if m.UpdateFunc == nil {
		panic("mocker: MockConnectionManagerInterface.UpdateFunc is nil but MockConnectionManagerInterface.Update was called.")
	}

	call := struct {
		Id string
		C  *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
	}{
		Id: id,
		C:  c,
	}

	m.calls.Update = append(m.calls.Update, call)

	return m.UpdateFunc(id, c)
}

// UpdateCalled returns true if Update was called at least once.
func (m *MockConnectionManagerInterface) UpdateCalled() bool {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	return len(m.calls.Update) > 0
}

// UpdateCalls returns the calls made to Update.
func (m *MockConnectionManagerInterface) UpdateCalls() []struct {
	Id string
	C  *github_com_confluentinc_cc_structs_kafka_auth_v1.Connection
} {
	m.lockUpdate.Lock()
	defer m.lockUpdate.Unlock()

	return m.calls.Update
}

// Delete mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) Delete(id string) error {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	if m.DeleteFunc == nil {
		panic("mocker: MockConnectionManagerInterface.DeleteFunc is nil but MockConnectionManagerInterface.Delete was called.")
	}

	call := struct {
		Id string
	}{
		Id: id,
	}

	m.calls.Delete = append(m.calls.Delete, call)

	return m.DeleteFunc(id)
}

// DeleteCalled returns true if Delete was called at least once.
func (m *MockConnectionManagerInterface) DeleteCalled() bool {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	return len(m.calls.Delete) > 0
}

// DeleteCalls returns the calls made to Delete.
func (m *MockConnectionManagerInterface) DeleteCalls() []struct {
	Id string
} {
	m.lockDelete.Lock()
	defer m.lockDelete.Unlock()

	return m.calls.Delete
}

// GetConnectionID mocks base method by wrapping the associated func.
func (m *MockConnectionManagerInterface) GetConnectionID(connectionName string) (string, error) {
	m.lockGetConnectionID.Lock()
	defer m.lockGetConnectionID.Unlock()

	if m.GetConnectionIDFunc == nil {
		panic("mocker: MockConnectionManagerInterface.GetConnectionIDFunc is nil but MockConnectionManagerInterface.GetConnectionID was called.")
	}

	call := struct {
		ConnectionName string
	}{
		ConnectionName: connectionName,
	}

	m.calls.GetConnectionID = append(m.calls.GetConnectionID, call)

	return m.GetConnectionIDFunc(connectionName)
}

// GetConnectionIDCalled returns true if GetConnectionID was called at least once.
func (m *MockConnectionManagerInterface) GetConnectionIDCalled() bool {
	m.lockGetConnectionID.Lock()
	defer m.lockGetConnectionID.Unlock()

	return len(m.calls.GetConnectionID) > 0
}

// GetConnectionIDCalls returns the calls made to GetConnectionID.
func (m *MockConnectionManagerInterface) GetConnectionIDCalls() []struct {
	ConnectionName string
} {
	m.lockGetConnectionID.Lock()
	defer m.lockGetConnectionID.Unlock()

	return m.calls.GetConnectionID
}

// Reset resets the calls made to the mocked methods.
func (m *MockConnectionManagerInterface) Reset() {
	m.lockCreate.Lock()
	m.calls.Create = nil
	m.lockCreate.Unlock()
	m.lockRead.Lock()
	m.calls.Read = nil
	m.lockRead.Unlock()
	m.lockList.Lock()
	m.calls.List = nil
	m.lockList.Unlock()
	m.lockUpdate.Lock()
	m.calls.Update = nil
	m.lockUpdate.Unlock()
	m.lockDelete.Lock()
	m.calls.Delete = nil
	m.lockDelete.Unlock()
	m.lockGetConnectionID.Lock()
	m.calls.GetConnectionID = nil
	m.lockGetConnectionID.Unlock()
}
